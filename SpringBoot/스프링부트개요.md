# Spring Boot

> 출처 : (youtube) "데어 프로그래밍" 님의 Springboot 강좌 - 개념정리

- 스프링은 프레임워크이다. 
  - 프레임워크는 만들어진 틀에서 벗어나지 않고 코딩할 수 있게 해주는 것.
  
- 스프링은 오픈소스이다.
  - 소스코드가 공개되어있다.
  
- 스프링은 IoC 컨테이너를 가진다.
  - IoC ( Inversion of Control ) : 제어의 역전  (주도권을 스프링이 갖고 있다)
  - class : 설계도
  - object : 실체화가 가능한 것.
  - instance : 실체화 된 것
  - 스프링이 클래스를 읽어서 heap 메모리에 올려준다.
  
- 스프링은 DI를 지원한다.
  - DI (Dependency Injection)
  - object를 스캔해서 메모리에 띄웠다. 이 스프링이 관리하는 객체를 내가 원하는 모든 클래스의 method에서 다른 클래스들을 가져와서 사용할 수 있다.
    - singleton으로 관리된다는 이야기. ex) 스캔했을 때 의자 클래스가 딱 한번만 메모리에 뜬다. 이 의자를 여기서도 갖다쓰고 저기서도 갖다쓴다. 이걸 DI라고 한다.
  
- 스프링은 엄청나게 많은 필터를 가지고 있다.

  - 필터는 누가 들어올 때 권한을 체크한다. 있으면 허락, 없으면 나가게 함.
  - 인터셉터도 마찬가지이다. (AOP)

- 스프링은 엄청나게 많은 어노테이션을 가지고 있다.

  - 주석 :

    -  코드 안에 설명글을 적을 수 있게 하는 것
    -  //으로 작성. ex) //로그인

  - 어노테이션 : 

    - 주석이다. 근데 컴파일러가 무시하지 않고 무언가를 체킹할 수 있게 힌트를 준다. 그래서 컴파일러가 무시하지 않는다. (컴파일체킹)

      - ex) Animal 클래스는 run() 메소드를 갖고 있다. Dog는 Animal 클래스를 상속하고 run() 메소드를 오버라이드한다. 이 때 @Override 라고 적어준다. 이제 이걸 컴파일할 때 run()이라는 메소드가 Animal에 있는지를 확인한다. run()이라는 메소드가 있으면 에러가 안나고, 만약 Animal 클래스에 run()이 없으면 컴파일 시에 에러가 난다.

    - 스프링에서는 어노테이션을 통해 주로 객체생성을 한다.

      - @Component : 클래스 메모리에 로딩해

      - @Autowired : 로딩된 객체를 해당 변수에 집어 넣어

      - 이러한 어노테이션을 직접 생성하고, 만들어두고 어노테이션의 역할을 미리 정해준다. 약속하는 느낌. 

      - 스프링에서는 IoC를 주로 사용한다고 했다. 이 때 @Component가 붙은 클래스를 스캔해서 heap 메모리 공간에 로딩한다. (어노테이션을 통해 IoC)

      - 그리고 Spring에서는 Java와 다르게 객체를 생성한다. ( 메모리에 생성된 객체들은 재사용하기 위해. )

        - ```java
          class B {
              @Autowired
              // A a = new A(); // 자바
              A a;
          }
          ```

        - 스프링이 B 클래스를 스캔할 때(읽어들일 때) B클래스 내부에 어떤 애가 있는지 분석(리플렉션). 이 리플렉션을 통해서 어떤 메서드, 필드, 어노테이션이 있는지 체킹한다. 있다면 무엇인가를 하라고 설정할 수 있다. 이 리플렉션을 통해서 @Autowired를 확인하고 "로딩된 객체를 해당 변수에 집어 넣어"를 실행한다. 

        - 쭉 읽어들여서 A와 같은 타입의 객체가 heap에 떠있는지를 확인한다. 만약 A가 없다면 @Autowired 밑의 a에는 null이 들어간다. A와 같은 타입의 객체를 찾는다면 그 A가 a에 들어간다. (DI)

  - 리플렉션 : 런타임 때 분석하는 기법.

- 스프링은 MessageConverter를 가지고 있다. 기본값은 현재 JSON이다.

  - 중간언어 : 예전엔 XML -> 요즘은 JSON
  - 자바 object ↔ 파이썬 object 를 이해하게 중간 언어로 JSON을 쓴다. 자바 object가 전송되기 직전에 JSON object으로 바뀌고 보내짐 → 받은 JSON object를 파이썬 object로 바꿈
  - JSON으로 바꿔주는 역할을 MessageConverter가 한다.

- 스프링은 BufferedReader와 BufferedWriter를 쉽게 사용할 수 있다.

  - 프로그래밍 통신 : 영어 한문자는 8bit(논리적으로 1byte라고 부름), 한글 한문자는 16bit
  - 1바이트는 하나의 문자를 표현. 
  - BufferedReader, BufferedWriter는 Byte Stream을 통해서 통신할 때 문자열을 가변길이로 쓰게 해주는 클래스이다.
    - @ResponseBody -> BufferedWriter
    - @RequestBody -> BufferedReader

- 스프링은 계속 발전중이다.



## JPA



**JPA는 Java Persistance API이다.** 

- Persistance : 영속성
- API : Application Programing Interface
  - Application : 프로그램
  - Programing : 프로그램을 만들기 위한 방법
  - Interface : 인터페이스
  - 즉, 프로그램을 만들기 위한 인터페이스를 제공하는 것이다.
  - 프로토콜 VS 인터페이스
    - 프로토콜 : 모든 사람이 동의할 수 있는 규칙 (동등한 관계의 약속) ex. WWW
    - 인터페이스 : 개발한 사람이 여러사람에게 공유하기 위해 단독으로 정해놓은 규칙 (상하관계가 존재하는 약속)
- RAM(전기) : 휘발성 저장소
- 하드디스크 : 비휘발성 저장소
- RAM의 데이터를 하드디스크에 기록한다.
- Persistance : 어떤 하나의 데이터가 영구히 기록될 수 있도록 하는 것.
- 자바에서는 DBMS에 기록한다.
- **JPA 란** : 자바에 있는 데이터를 영구히 기록할 수 있는 환경인 DBMS에 기록하게 해주는 API



**JPA는 ORM 기술이다.**

- ORM : Object Relational Mapping. 객체를 DB에 연결하는 방법론.

- Java가 갖고있는 데이터 타입과 DB의 데이터 타입이 다르다. 그래서 DB에 있는 테이블을 모델링 해야한다.

- 먼저 DB에 테이블을 만들고

- | 이름 | 타입    |
  | ---- | ------- |
  | ID   | int     |
  | Name | varchar |
  | year | varchar |

- DB의 데이터를 자바에 모델링.

- ```java
  Class Team {
      int id;
      String name;
      String year;
  }
  ```

- 근데 이 상황을 완전히 역전시킬 수 있다.

- 자바에서 먼저 클래스를 만들고 실행하면 그 클래스의 테이블이 자동으로 생성되게 하는 기법을 ORM이라고 한다.



**JPA는 반복적인 CRUD 작업을 생략하게 해준다.**

- 자바에서 DB에게 connection을 요청한다. 신원 확인 후 세션을 오픈한다. 자바는 connection을 갖게 된다. 
- 이후 쿼리를 전송한다. 그 쿼리에 맞는 데이터를 응답한다.
- 응답 데이터 타입과 자바데이터 타입이 다르기 때문에 응답 데이터를 받아서 자바 오브젝트로 변경한다.
- 이 로직이 단순 반복이다. JPA는 이것을 줄이게 해준다.
- 전송된 쿼리에 대한 응답이 있을 때, 내가 이 데이터를 받고, 받은 데이터를 자바오브젝트로 바꾸고, 연결된 세션을 끊고, 연결된 커넥션을 끊는 코드들을 JPA는 함수 하나로 제공해준다. 기본적으로 반복되는 CRUD를 단순히 처리하게 해준다.



**JPA는 영속성 컨텍스트를 가지고 있다.**

- 컨텍스트 : 모든 정보를 뜻한다.
- 영속성 컨텍스트
  - DB에 어떤 데이터를 저장하고 싶다. 
  - 어떤 데이터와 DB 사이에는 영속성컨텍스트가 있다.
  - 영속성 컨텍스트는 자바가 DB에 데이터를 저장해야되는 모든 것을 알고있는 것.
  - 자바에서는 어떤 데이터를 영속성컨텍스트(자바내에있음)에 던진다. 영속성컨텍스트에 들어있는 어떤 데이터를 DB에 던진다. DB에 어떤 데이터가 저장이 된 것이다.
  - 영속성컨텍스트 안의 어떤 데이터를 삭제하고 다시 DB에 던지면 DB의 어떤 데이터도 삭제된다. (영속성컨텍스트와 DB는 동기화 되어있다.)
  - 자바 내의 어떤 데이터를 수정하면 영속성컨텍스트내에 있는 어떤 데이터도 수정된다. 이후 DB에 commit 해서 데이터를 밀어 넣으면 원래의 어떤 데이터의 형상이 달라진 것을 파악하고 INSERT가 아닌 UPDATE가 된다.
  - 자바라는 애가 DB에 저장하고 DB의 데이터를 가져오는 일련의 모든 정보를 영속성컨텍스트를 통해서 다 확인할 수 있다. 즉, 영속성컨텍스트는 자바가 DB에 저장해야되는 모든 메타데이터 정보들을 갖고 있다.



**JPA는 DB와 OOP의 불일치성을 해결하기 위한 방법론을 제공한다. (DB는 객체저장 불가능)**

- DB에서는 사용자가 원하는 데이터를 가져오려면 두번의 select 나 join을 통해서 가져와야한다. ex) 팀 테이블, 선수 테이블

- OOP 관점에서 보면

- ```java
  Class player {
      int id;
      String name;
      Team team; = team_object // 팀 오브젝트
  }
  ```

- 이다.

- JPA에서는 모델을 만들 때 자바가 주도권을 쥐고있는 모델을 만들 수 있다.

- 그리고 JPA는 데이터를 insert나 select할 때 자동으로 매핑해서 데이터를 object에 넣어준다.



**JPA는 OOP의 관점에서 모델링을 할 수 있게 해준다. (상속, 컴포지션, 연관관계)**



```java
Class Car extends EntityDate{
    int id; // pk
    String name;
    String color;
    Engine engine; //컴포지션
}

Class Engine extends EntityDate{
    int id;
	int power;
}

Class EntityDate {
    TimeStamp createDate;
    TimeStamp updateDate;
}
```

- Engine 클래스를 Car 클래스에서 쓰고 싶어서 상속을 하게되면 자동차의 부모가 엔진이 되는 부모관계가 되어서 말이 안된다.

- 상속말고 컴포지션(결합)을 사용해야 한다.

- 클래스를 토대로 자동생성해서 데이터베이스 테이블을 만들어주는 기법이므로 

  - Car 테이블

  - | id   | name   | color | engineId |
    | ---- | ------ | ----- | -------- |
    | 1    | BMW    | white | 2        |
    | 2    | Sonata | black | 1        |

  - Engine 테이블

  - | id   | power |
    | ---- | ----- |
    | 1    | 2000  |
    | 2    | 4000  |

- 이런식으로 생성될 것이다.



**방언 처리가 용이하여 Migration하기 좋음. 유지보수에도 좋음**

- 스프링 - JPA - (추상화객체) - DB
- 추상화 객체 : 여러 DB 중에 어떤 DB가 연결 될지 몰라서 연결을 위한 만들어두는 객체 (오라클, 마리아, MSSQL, MYSQL, Postgre 등등)
- 즉, SQL 코드가 달라도 연결이 원활하게 되도록 해준다.





## 스프링부트 동작원리



### 1. 내장 톰켓을 가진다

- 톰켓을 따로 설치할 필요 없이 바로 실행가능하다.
- 우선 통신의 진화과정에 대해 알아보자. **Socket**  :
  - 운영체제가 갖고 있는 것.
  - A와 B가 서로 메시지를 교환하기 위해서 운영체제가 갖고있는 Socket을 이용함. 
  - 처음에 A가 Socket을 오픈한다. B는 A가 오픈한 Socket의 포트번호(5000)와 A의 IP주소(ip주소:5000)를 넣으면 A와 B는 메시지를 주고받을 수 있는 통신이 가능하다.
  - 이렇게만 만들면 새로운 사람 C가 5000번 포트와 연결할 방법이 없다.
  - 그래서 B가 5000번 포트에 연결되는 순간 A에 새로운 socket을 만들고(번호는 랜덤. 여기서는 5001. 새로운 스레드도 같이 생성한다), 5000번 포트의 연결을 끊기고, 새로운 5001번 포트의 socket으로 통신을 하게 된다.
  - 결국 5000번 소켓(main 스레드)는 계속해서 통신 연결을 받고 넘기고 끊고, 새로 생성되는 소켓(새로 생성되는 스레드)들이 연결된다.
  - 하지만 한번 생성된 소켓들의 연결이 끊어지지 않기 때문에 시스템에 가해지는 부하가 크다.
- 그래서 **http 통신**은 무연결성을 지향한다. (stateless 방식)
  - http는 단순히 문서를 전달하는 통신
  - B, C가 A에게 request했을 때, 새로운 소켓을 만드는 것이 아니라, 그냥 문서를 전달하고(response) 연결을 끊어버린다. 
  - http 통신의 단점으로는 누가 요청했는지를 모른다. (구분을 못함)
  - 응답할 때 A의 입장에서는 B, C의 IP를 몰라도 된다. B,C 컴퓨터에서 자원을 가져올 일이 없기 때문이다. 이렇게 되면 A가 웹 서버가 되는 것이다.
  - A가 못하는 일: B,C가 요청하지 않았을 때 A는 응답을 할 수가 없다. 이걸 해결하기 위해서는 소켓을 연결해야 한다. 그러면 원하는 시점에 데이터를 전달해줄 수 있다.
- 톰켓:
  - 요청파일중에 JSP(자바파일)이 요청되면 그것을 컴파일해서 html파일로 돌려주는 것. 
  - 아파치는 요청한 파일을 응답해주는 것. (웹서버)
  - ex) 웹 서버: 아파치 + 톰켓
    - 아파치에 JSP파일로 request가 온다. 그러면 이 JSP파일을 톰켓을 통해서 html으로 바꿔서 이 html을 response한다.
- 웹 브라우저는 단순한 기능만을 한다. html, js, css파일을 (통신을 통해서) 읽어주는 프로그램이다. 이해하지 못하는 확장자는 읽을 수 없다.





### 2. 서블릿 컨테이너(톰켓)

- 요청을 받을 때 무조건 동기화하는 것은 아니다.
- 정적인 파일을 요청하면 아파치가 돈다.
- url : 자원 접근 (ex. http://temp.com/a.png)
- uri : 식별자 접근 (ex. http://temp.com/picture/a)
- 스프링은 url을 전부 막아놨다. uri로 접근해야한다(식별자를 활용하여)
  - 특정한 파일 요청을 할 수 없다.
  - 요청시에는 무조건 자바를 거친다.
- 요청이 왔을 때 servelet 컨테이너가 객체를 생성하는 방식 :
  - servelet : 자바 코드로 웹을 할 수 있는 것
  - 톰켓은 요청이 왔을 때 쓰레드를 만든다. 이 스레드가 서블릿객체를 만든다. 이 객체에서 DB connect, 필요한 데이터 가져오고 하는 많은 작업을 하여 마지막에 html으로 바꿔서 응답한다. 
  - 스레드 생성은 제한된 갯수만큼 생성되고 그 이상으로 요청이 들어오면 대기한다.
  - 업무가 끝난 스레드가 있다면 그 스레드에 요청이 할당된다.
- Client -> 
  - 서블릿 컨테이너 -> 
    - 최초요청 이라면
      - 메모리 로딩
        - 객체 생성
          - init()
            - Service(HttpServeletRequest, HttpServeletResponse)
    - 최초요청이 아니라면
      - 바로 Service(HttpServeletRequest, HttpServeletResponse)



### 8. 요청 주소에 따른 적절한 컨트롤로 요청 (Handler Mapping)

GET 요청 -> http://localhost:8080/post/1

해당 주소요청이 오면 적절한 컨트롤러의 함수를 찾아서 실행한다.



## 9. 응답

html 파일을 응답할지 Data를 응답할지 결정해야 하는데 html 파일을 응답하게 되면 ViewResolver가 관여하게 된다.

하지만 Data를 응답하게 되면 MessageConverter가 작동하게 되는데 메시지를 컨버팅할 때 기본전략은 JSON이다.













## 스프링 부트 입문

> 출처 : (youtube) "홍팍" 님의 스프링 부트 입문



### spring boot 파일 구조

- src
  - main
    - java : 자바 파일이 모두 들어간다.
      - com.example.{projectname} (기본 패키지)
        - {projectname}Application.java 안에 public static void main 메소드가 있다. 이 {projectname}Application를 실행시키면 프로젝트가 실행된다.
        - controller
          - 
    - resources : 리소스들이 들어간다.
      - static
      - templates
        - 템플릿들



### MVC 패턴

- 역할 : 
  - Model : 데이터
  - View : 이번 프로젝트에서는 프론트엔드 서버를 따로 활용
  - Control : src/main/java/각패키지/controller 내부에 있음





### 폼데이터 주고받기

form -> DTO -> Controller

DTO란?

- Data Transfer Object : 데이터 전송 객체
- Dto는 클라이언트와 서버의 서비스 계층 사이에서 교환되는 데이터를 담는 그릇이다.
- 서버에 엔티티



model의 예시

```java
// 하단 DB 설정 부분은 Sub PJT II에서 데이터베이스를 구성한 이후에 주석을 해제하여 사용. -> 이게 무슨소리지...? 맨 처음에 주석이 아무것도 달려있지 않았는데?

package com.web.curation.model.user;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;

import java.time.LocalDateTime;

@Entity // 서버 실행 시에 Object Relation Mapping이 됨
@Data // getter, setter를 만드는 것. 원래 아름답게 하려면 setter만 만들고 DTO로 받아서 데이터를 넣을 수 잇는 함수 하나만 만들면 됨.
@NoArgsConstructor  // 
@AllArgsConstructor  // 
@JsonInclude(JsonInclude.Include.NON_NULL)
public class User {
    @Id // PK를 해당 변수로 하겠다는 뜻
    @GeneratedValue(strategy = GenerationType.IDENTITY) // 해당 데이터베이스 번호증가 전략을 따라가겠다.
    private String uid;

    @JsonIgnore
    private String password;
    private String email;

    @Column(insertable = false, updatable = false)
    private LocalDateTime createDate;

    //아름답게 하려면의 그 함수
    //public static setBook(Dto dto) {
        // title = dto.getTitle();
        // author = dto.getAuthor();
    // }
}
```





application.yml

```
server:
	servelet:
		encoding:
			charset: utf-8
			enable: true

spring:
	datasource
		url:
		driver-class-name:
		username:
		password:

jpa:
	hibernate:
		ddl-auto: create @ create, update, none
		naming :
			physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
```











Dto

Repository

JPA를 쓰면 service가 필요 없음

controller




