# Spring Boot

- 스프링은 프레임워크이다. 
  - 프레임워크는 만들어진 틀에서 벗어나지 않고 코딩할 수 있게 해주는 것.
  
- 스프링은 오픈소스이다.
  - 소스코드가 공개되어있다.
  
- 스프링은 IoC 컨테이너를 가진다.
  - IoC ( Inversion of Control ) : 제어의 역전  (주도권을 스프링이 갖고 있다)
  - class : 설계도
  - object : 실체화가 가능한 것.
  - instance : 실체화 된 것
  - 스프링이 클래스를 읽어서 heap 메모리에 올려준다.
  
- 스프링은 DI를 지원한다.
  - DI (Dependency Injection)
  - object를 스캔해서 메모리에 띄웠다. 이 스프링이 관리하는 객체를 내가 원하는 모든 클래스의 method에서 다른 클래스들을 가져와서 사용할 수 있다.
    - singleton으로 관리된다는 이야기. ex) 스캔했을 때 의자 클래스가 딱 한번만 메모리에 뜬다. 이 의자를 여기서도 갖다쓰고 저기서도 갖다쓴다. 이걸 DI라고 한다.
  
- 스프링은 엄청나게 많은 필터를 가지고 있다.

  - 필터는 누가 들어올 때 권한을 체크한다. 있으면 허락, 없으면 나가게 함.
  - 인터셉터도 마찬가지이다. (AOP)

- 스프링은 엄청나게 많은 어노테이션을 가지고 있다.

  - 주석 :

    -  // 글~

  - 어노테이션 : 

    - 주석이다. 근데 컴파일러가 무시하지 않고 무언가를 체킹할 수 있게 힌트를 준다. 그래서 컴파일러가 무시하지 않는다. (컴파일체킹)

      - ex) Animal 클래스는 run() 메소드를 갖고 있다. Dog는 Animal 클래스를 상속하고 run() 메소드를 오버라이드한다. 이 때 @Override 라고 적어준다. 이제 이걸 컴파일할 때 run()이라는 메소드가 Animal에 있는지를 확인한다. run()이라는 메소드가 있으면 에러가 안나고, 만약 Animal 클래스에 run()이 없으면 컴파일 시에 에러가 난다.

    - 스프링에서는 어노테이션을 통해 주로 객체생성을 한다.

      - @Component : 클래스 메모리에 로딩해

      - @Autowired : 로딩된 객체를 해당 변수에 집어 넣어

      - 이러한 어노테이션을 직접 생성하고, 만들어두고 어노테이션의 역할을 미리 정해준다. 약속하는 느낌. 

      - 스프링에서는 IoC를 주로 사용한다고 했다. 이 때 @Component가 붙은 클래스를 스캔해서 heap 메모리 공간에 로딩한다. (어노테이션을 통해 IoC)

      - 그리고 Spring에서는 Java와 다르게 객체를 생성한다. ( 메모리에 생성된 객체들은 재사용하기 위해. )

        - ```java
          class B {
              @Autowired
              // A a = new A(); // 자바
              A a;
          }
          ```

        - 스프링이 B 클래스를 스캔할 때(읽어들일 때) B클래스 내부에 어떤 애가 있는지 분석(리플렉션). 이 리플렉션을 통해서 어떤 메서드, 필드, 어노테이션이 있는지 체킹한다. 있다면 무엇인가를 하라고 설정할 수 있다. 이 리플렉션을 통해서 @Autowired를 확인하고 "로딩된 객체를 해당 변수에 집어 넣어"를 실행한다. 

        - 쭉 읽어들여서 A와 같은 타입의 객체가 heap에 떠있는지를 확인한다. 만약 A가 없다면 @Autowired 밑의 a에는 null이 들어간다. A와 같은 타입의 객체를 찾는다면 그 A가 a에 들어간다. (DI)

  - 리플렉션 : 런타임 때 분석하는 기법.

- 스프링은 MessageConverter를 가지고 있다. 기본값은 현재 JSON이다.

  - 중간언어 : 예전엔 XML -> 요즘은 JSON
  - 자바 object ↔ 파이썬 object 를 이해하게 중간 언어로 JSON을 쓴다. 자바 object가 전송되기 직전에 JSON object으로 바뀌고 보내짐 → 받은 JSON object를 파이썬 object로 바꿈
  - JSON으로 바꿔주는 역할을 MessageConverter가 한다.

- 스프링은 BufferedReader와 BufferedWriter를 쉽게 사용할 수 있다.

  - 프로그래밍 통신 : 영어 한문자는 8bit(논리적으로 1byte라고 부름), 한글 한문자는 16bit
  - 1바이트는 하나의 문자를 표현. 
  - BufferedReader, BufferedWriter는 Byte Stream을 통해서 통신할 때 문자열을 가변길이로 쓰게 해주는 클래스이다.
    - @ResponseBody -> BufferedWriter
    - @RequestBody -> BufferedReader

- 스프링은 계속 발전중이다.



## JPA



**JPA는 Java Persistance API이다.** 

- Persistance : 영속성
- API : Application Programing Interface
  - Application : 프로그램
  - Programing : 프로그램을 만들기 위한 방법
  - Interface : 인터페이스
  - 즉, 프로그램을 만들기 위한 인터페이스를 제공하는 것이다.
  - 프로토콜 VS 인터페이스
    - 프로토콜 : 모든 사람이 동의할 수 있는 규칙 (동등한 관계의 약속) ex. WWW
    - 인터페이스 : 개발한 사람이 여러사람에게 공유하기 위해 단독으로 정해놓은 규칙 (상하관계가 존재하는 약속)
- RAM(전기) : 휘발성 저장소
- 하드디스크 : 비휘발성 저장소
- RAM의 데이터를 하드디스크에 기록한다.
- Persistance : 어떤 하나의 데이터가 영구히 기록될 수 있도록 하는 것.
- 자바에서는 DBMS에 기록한다.
- **JPA 란** : 자바에 있는 데이터를 영구히 기록할 수 있는 환경인 DBMS에 기록하게 해주는 API



**JPA는 ORM 기술이다.**

- ORM : Object Relational Mapping. 객체를 DB에 연결하는 방법론.

- Java가 갖고있는 데이터 타입과 DB의 데이터 타입이 다르다. 그래서 DB에 있는 테이블을 모델링 해야한다.

- 먼저 DB에 테이블을 만들고

- | 이름 | 타입    |
  | ---- | ------- |
  | ID   | int     |
  | Name | varchar |
  | year | varchar |

- DB의 데이터를 자바에 모델링.

- ```java
  Class Team {
      int id;
      String name;
      String year;
  }
  ```

- 근데 이 상황을 완전히 역전시킬 수 있다.

- 자바에서 먼저 클래스를 만들고 실행하면 그 클래스의 테이블이 자동으로 생성되게 하는 기법을 ORM이라고 한다.



**JPA는 반복적인 CRUD 작업을 생략하게 해준다.**

- 자바에서 DB에게 connection을 요청한다. 신원 확인 후 세션을 오픈한다. 자바는 connection을 갖게 된다. 
- 이후 쿼리를 전송한다. 그 쿼리에 맞는 데이터를 응답한다.
- 응답 데이터 타입과 자바데이터 타입이 다르기 때문에 응답 데이터를 받아서 자바 오브젝트로 변경한다.
- 이 로직이 단순 반복이다. JPA는 이것을 줄이게 해준다.
- 전송된 쿼리에 대한 응답이 있을 때, 내가 이 데이터를 받고, 받은 데이터를 자바오브젝트로 바꾸고, 연결된 세션을 끊고, 연결된 커넥션을 끊는 코드들을 JPA는 함수 하나로 제공해준다. 기본적으로 반복되는 CRUD를 단순히 처리하게 해준다.



**JPA는 영속성 컨텍스트를 가지고 있다.**

- 컨텍스트 : 모든 정보를 뜻한다.
- 영속성 컨텍스트
  - DB에 어떤 데이터를 저장하고 싶다. 
  - 어떤 데이터와 DB 사이에는 영속성컨텍스트가 있다.
  - 영속성 컨텍스트는 자바가 DB에 데이터를 저장해야되는 모든 것을 알고있는 것.
  - 자바에서는 어떤 데이터를 영속성컨텍스트(자바내에있음)에 던진다. 영속성컨텍스트에 들어있는 어떤 데이터를 DB에 던진다. DB에 어떤 데이터가 저장이 된 것이다.
  - 영속성컨텍스트 안의 어떤 데이터를 삭제하고 다시 DB에 던지면 DB의 어떤 데이터도 삭제된다. (영속성컨텍스트와 DB는 동기화 되어있다.)
  - 자바 내의 어떤 데이터를 수정하면 영속성컨텍스트내에 있는 어떤 데이터도 수정된다. 이후 DB에 commit 해서 데이터를 밀어 넣으면 원래의 어떤 데이터의 형상이 달라진 것을 파악하고 INSERT가 아닌 UPDATE가 된다.
  - 자바라는 애가 DB에 저장하고 DB의 데이터를 가져오는 일련의 모든 정보를 영속성컨텍스트를 통해서 다 확인할 수 있다. 즉, 영속성컨텍스트는 자바가 DB에 저장해야되는 모든 메타데이터 정보들을 갖고 있다.



**JPA는 DB와 OOP의 불일치성을 해결하기 위한 방법론을 제공한다. (DB는 객체저장 불가능)**

https://www.youtube.com/watch?v=tXyDmqoMmKE&list=PL93mKxaRDidG_OIfRQ4nztPQ13y74lCYg&index=7

11:00까지



**JPA는 OOP의 관점에서 모델링을 할 수 있게 해준다. (상속, 콤포지션, 연관관계)**





